services:
  backend:
  #Will find the DockerFile inside flask-server/
    build: ./flask-server
    # Usually we don't put a name on a container_name, so it choose it alone.
    container_name: react_flask_backend
    #This is use to synchronize our folder flask-server and /app
    #This is usefull too because when we change our code is instant visible.
    #Format port_hote:port_container
    volumes:
      - ./flask-server:/app
    ports:
      - "${BACKEND_HOST_PORT:-5000}:5000"
    environment:
      - FLASK_ENV=development
      - DB_HOST=db
      - DB_NAME=${DB_NAME:-react_flask_db}
      - DB_USER=${DB_USER:-root}
      - DB_PASSWORD=${DB_PASSWORD:-mypassword}
    env_file:
      - .env
      #It launch after the bdd.
    depends_on:
      - db
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:5000/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5

  frontend:
    build: ./app
    container_name: react_flask_frontend
    volumes:
      - ./app:/usr/src/app
      # Protect the node_modules. 
      - /usr/src/app/node_modules
    ports:
      - "${FRONTEND_HOST_PORT:-5173}:5173"
    environment:
      - CHOKIDAR_USEPOLLING=true
    depends_on:
      - backend

  db:
  #No need dockerfile, it download the official image.
    image: mysql:8.0
    container_name: react_flask_db
    restart: unless-stopped
    env_file:
      - .env
    environment:
      MYSQL_ROOT_PASSWORD: "${DB_PASSWORD:-mypassword}"
      MYSQL_DATABASE: "${DB_NAME:-react_flask_db}"
      MYSQL_USER: "${DB_USER:-root}"
      MYSQL_PASSWORD: "${DB_PASSWORD:-mypassword}"
   #Where mysql get his data.
    volumes:
      - db-data:/var/lib/mysql
      # Initialize DB schema on first run
      - ./flask-server/schema.sql:/docker-entrypoint-initdb.d/schema.sql:ro
    healthcheck:
      test: ["CMD-SHELL", "mysqladmin ping -h localhost -p${DB_PASSWORD:-mypassword} || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  db-data:
